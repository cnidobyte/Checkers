package core;
import java.util.ArrayList;
import java.lang.IllegalArgumentException;

/**
 * The <b><em>Move</em></b> Class contains the coordinates of moves input by the user or generated by the computer.
 * 
 * @author Shota
 *
 */

public class Move {
	/**
	 * Field Summary.
	 */
	private int xSource, ySource, xDestination, yDestination, xMidpoint, yMidpoint;
	private boolean jump;
	private Coordinate sourceCoords = new Coordinate();
	private Coordinate destinationCoords = new Coordinate();
	private Coordinate midpointCoords = new Coordinate();
	
	/**
	 * Constructor Summary.
	 * @param String
	 */
	Move(String move) {
		move = move.toUpperCase();
		
		try { 
			if(move.length() != 5) {
				throw new IllegalArgumentException("Not a valid input. Entry must look like 3B-4C. Try again.");
			}
			xSource = Math.abs(move.charAt(0) - 56);
			ySource = move.charAt(1) - 'A';
			xDestination = Math.abs(move.charAt(3) - 56);
			yDestination = move.charAt(4) - 'A';
			jump = (xSource - xDestination == -2 || xSource - xDestination == 2);
			xMidpoint = (xSource + xDestination) / 2;
			yMidpoint = (ySource + yDestination) / 2;
			
			sourceCoords.addCoord(xSource);
			sourceCoords.addCoord(ySource);
			destinationCoords.addCoord(xDestination);
			destinationCoords.addCoord(yDestination);
			midpointCoords.addCoord(xMidpoint);
			midpointCoords.addCoord(yMidpoint);
		} 
		catch (IllegalArgumentException ex){
			System.out.print(ex);
		}

	}
	Move(int xStart, int xEnd, int yStart, int yEnd) {
		xSource = xStart;
		ySource = yStart;
		xDestination = xEnd;
		yDestination = yEnd;
		jump = (xSource - xDestination == -2 || xSource - xDestination == 2);
		xMidpoint = (xSource + xDestination) / 2;
		yMidpoint = (ySource + yDestination) / 2;
		
		sourceCoords.addCoord(xSource);
		sourceCoords.addCoord(ySource);
		destinationCoords.addCoord(xDestination);
		destinationCoords.addCoord(yDestination);
		midpointCoords.addCoord(xMidpoint);
		midpointCoords.addCoord(yMidpoint);
	}
	/**
	 * Determines whether a move is within the bounds of the game and therefore legal.
	 * @return boolean  returns true if coordinates are in the bounds of the board.
	 */
	public boolean isInBounds() {
		boolean result = true;
		if(inBoundsHelper(xSource))
			return false; 
		if(inBoundsHelper(ySource))
			return false;
		if(inBoundsHelper(xDestination))
			return false;
		if(inBoundsHelper(yDestination))
			return false;
		return result;
	}
	private boolean inBoundsHelper(int fragment) {
		return (fragment < 0 || fragment > 8);
	}
	
	/**
	 * Getter function for jump
	 * @return boolean
	 */
	public boolean isJump() {
		return jump;
	}
	/**
	 * Getter function for adjacency.
	 * @return boolean
	 */
	public boolean isAdjacent() {
		return (xDestination - xSource == -1 || xSource - xDestination == -1
				&& yDestination - ySource == -1 || ySource - yDestination == -1);
	}
	
	/**
	 * Accessor for source coordinates.
	 * @return ArrayList<Integer>
	 */
	public Coordinate getSourceCoords() {
		return sourceCoords;
	}
	
	/**
	 * Accessor for destination coordinates.
	 * @return destinationCoords  coordinate pair for where the piece lands.
	 */
	public Coordinate getDestinationCoords() {
		return destinationCoords;
	}
	
	/**
	 * Accessor for midpoint coordinates.
	 * @return midpointCoords  coordinate pair for the middle spot of a jump.
	 */
	public Coordinate getMidpointCoords() {
		return midpointCoords;
	}
}
